 \documentclass[11pt]{article}
\usepackage{amsmath, amssymb, enumerate, mathpazo, mathrsfs, fancyhdr, mathrsfs, graphicx, framed, float}
\usepackage[tmargin = 1in, lmargin = 1.1in, rmargin = 1in, bmargin = 1in]{geometry}
%%%%%%%%%%%%%%%%%%%%%%% IMPORTANT %%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                                                             %
%       In the end, we should submit only algorithms.pdf      %
%                                                             %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\usepackage{courier}
\usepackage{color}
\usepackage{listings}
\lstset{ %
language=erlang,            % choose the language of the code
basicstyle=\footnotesize,   % the size of the fonts that are used for the code
numbers=left,               % where to put the line-numbers
numberstyle=\footnotesize,  % the size of the fonts that are used for the line-numbers
stepnumber=1,               % the step between two line-numbers. If it is 1 each line will be numbered
numbersep=5pt,              % how far the line-numbers are from the code
backgroundcolor=\color{white}, % choose the background color. You must add \usepackage{color}
showspaces=false,           % show spaces adding particular underscores
showstringspaces=false,     % underline spaces within strings
showtabs=false,             % show tabs within strings adding particular underscores
frame=single,               % adds a frame around the code
tabsize=2,                  % sets default tabsize to 2 spaces
captionpos=b,               % sets the caption-position to bottom
breaklines=true,            % sets automatic line breaking
breakatwhitespace=false,    % sets if automatic breaks should only happen at whitespace
escapeinside={\%*}{*)} % if you want to add a comment within your code
}

%%% MACROS
\newcommand{\pic}[2]{\begin{center}\includegraphics[scale=#1]{#2}\end{center}}
\newcommand{\union}{\cup}
\newcommand{\intersect}{\cap}
\newcommand{\dx}{\,\mathrm{d}x}
\newcommand{\comp}[1]{\overline{#1}}

%%% MATH OPERATORS
\DeclareMathOperator{\var}{Var}

%%% PARAMETERS
\setlength{\headheight}{15.2pt}
\renewcommand{\tabcolsep}{1cm}

%%% ENUMERATE
\renewcommand{\theenumi}{\alph{enumi}}
\renewcommand{\labelenumi}{(\theenumi)}
\renewcommand{\theenumii}{\roman{enumii}}
\renewcommand{\labelenumii}{\theenumii.}

\title{The Algorithm for the Distributed Key-Value Storage Problem}

%%% PROBLEM ENVIRONMENT
\newenvironment{problem}[1]{
\medskip \hrule \medskip
\noindent {\bf Problem #1.}
}{
\medskip \hrule \medskip
}

%%% SOLUTION ENVIRONMENT
\newenvironment{solution}{\noindent{\bf Solution.} }{

\hfill$\square$}

\begin{document}
\pagestyle{fancy}

\lhead{Tum C., Cory P.
}
\chead{\bf{CSCI 182E} Distributed Systems}
\rhead{April 10, 2014}

\vspace*{0.1in}
\begin{center} \Large The Algorithm for the Distributed Key-Value Storage Problem \end{center}

\section{The Distributed Key-Value Storage}
\begin{problem}{Statement}
We need to develop and implement an algorithm for the distributed key-value storage system, which involves distributed computations such as snapshot algorithms when the external world asks a question about the entire system. The system must be fault tolerant, correct, highly available, and reasonably fast.
\end{problem}

Our snapshot algorithm is based on the Chandy-Lamport algorithm.


\section{The Algorithm}
\subsection{A set of states}
Each of the philosophers must be in one of the following 6 states:
\newcommand{\numStates}{six}
\newcommand{\joining}{\textit{joining}}
\newcommand{\available}{\textit{available}}
\newcommand{\leaving}{\textit{leaving}}
\newcommand{\gone}{\textit{gone}}
\newcommand{\red}{\textit{red}}
\newcommand{\white}{\textit{white}}
\begin{enumerate}
\item \joining
\item \available
\item \leaving
\item \gone
\item \red
\item \white
\end{enumerate}


\subsection{Information Stored by Each Process}
In the Erlang syntax, the $\texttt{TODO}$ function's header represents
the information stored by each process:
\begin{lstlisting}
TODO(<state>, Node, Neighbors)
\end{lstlisting}
In other words, a process $p$ contains the following information:
\begin{enumerate}
\item $p.m$ ($m$): the parameter $m$.
\item $p.state$ ($\langle\texttt{state}\rangle$): one of the \numStates states outlined above.
\item $p.node$ its process node ($\texttt{Node}$), represented as a lowercase ASCII string with a machine name, separated by an @ symbol. (For example, \texttt{p1@ash}) We can always find out our nodename with node(), so it is not passed around.
\item $p.neighbors$ ($\texttt{Neighbors}$): a list of its neighboring processes $[n_1, n_2, \ldots, n_k]$.
\end{enumerate}

\subsection{Message Types in the System}
We categorize messages by its sender and its receiver:
\subsubsection{From Storage Processes to Storage Processes}
\begin{enumerate}[M1]
\item \label{M:fork} Lots of messages going on here.
\end{enumerate}

\subsubsection{From Storage Processes to Non-Storage Processes}
\begin{enumerate}[M1]
\setcounter{enumi}{6}
\item \label{M:become_hungry} something.
\end{enumerate}

\subsubsection{From Non-Storage Processes to Storage Processes}
\begin{enumerate}[M1]
\setcounter{enumi}{9}
\item an \texttt{store} Something.
\item an \texttt{stored} Something.
\item an \texttt{store} Something.
\item an \texttt{store} Something.
\end{enumerate}

\subsubsection{From Non-Storage Processes to Non-Storage Processes}
\begin{enumerate}[M1]
\setcounter{enumi}{9}
\item an \texttt{eating} Something.
\end{enumerate}


\subsubsection{From Processes to External Controllers}
\begin{enumerate}[M1]
\setcounter{enumi}{9}
\item a \texttt{stored} Something.
\item a \texttt{retrieved} Something.
\item a \texttt{result} Something.
\item a \texttt{failure} Something.
\end{enumerate}

\subsubsection{From External Controllers to Processes}
\begin{enumerate}[M1]
\setcounter{enumi}{9}
\item a \texttt{store} Something.
\item a \texttt{retrieve} Something.
\item a \texttt{first\_key} Something.
\item a \texttt{last\_key} Something.
\item a \texttt{num\_keys} Something.
\item a \texttt{node\_list} Something.
\item a \texttt{leave} Something.
\end{enumerate}

\subsection{Initial States of the System}
\begin{enumerate}
\item TODO
\end{enumerate}

\subsection{Actions before and after Transitions}
\begin{figure}[H]
\pic{0.6}{diagram}
\label{fig:diagram}
\caption{A diagram showing possible state transitions.}
\end{figure}

We will describe what would happen when a philosopher receives a fork.


\begin{description}
\item[(1) $p.joining$ $\to$ $p.available$:] sends a joining request to all of its neighbors. Once it receives all joining message acknowledgments from all its neighbors, transitions to the \textit{thinking} state.

\item[(5) $(p.leaving \vee p.red \vee p.white)$ $\to$ $p.leaving$:] checks to see if it has already received a \texttt{leave} message from an external controller. If so, the process transitions to the \textit{leaving} state and sends leaving notifications to all of its neighbors. 

\item[(6) $p.leaving$ $\to$ $p.gone$:]
once it receives leaving notification acknowledgements from all of its neighbors to whom it sent leaving notifications, it transitions to the \gone state. At this stage, it knows that all of its neighbors are aware of its leaving and already deleted it from their neighbors list. With this knowledge, it then deletes all its neighbors from its neighbors list.
\end{description}

Now we need to define what should happen when a process $p$ receives an incoming message depending on what state it currently is in.

\subsection{Actions for Incoming Joining Request Messages (M\ref{M:joining_request})}
\begin{description}
\item[Received in the \textit{joining} state:] holds onto the request until it successfully joins and transitioned to thinking. This prevents odd joining circles that lead to deadlocks.
\item[Received in the \textit{thinking} state:] approves request and creates a dirty fork for the edge.
\item[Received in the \textit{hungry} state:] approves request and creates a dirty fork for the edge.
\item[Received in the \textit{eating} state:] approves request and creates a dirty fork for the edge.
\item[Received in the \textit{leaving} state:] the assignment specifies that we do not have to handle this situation, the external controller should know better.
\item[Received in the \textit{gone} state:] not possible
\end{description}

\subsection{Actions for Incoming Joining Message Acknowledgement Messages (M\ref{M:joining_ack})}
\begin{description}
\item[Received in the \textit{joining} state:] adds that neighbor to the forklist, saying you don't have the fork. Then it tries to contact the rest of your neighbors. Once all neighbors have sent it an \texttt{ok}, it can transition to the \emph{thinking} state.
\item[Received in the \textit{thinking} state:] not possible.
\item[Received in the \textit{hungry} state:] not possible.
\item[Received in the \textit{eating} state:] not possible.
\item[Received in the \textit{leaving} state:] not possible.
\item[Received in the \textit{gone} state:] not possible.
\end{description}

\subsection{Actions for Incoming Leaving Notification Messages (M\ref{M:leaving_notification})}
\begin{description}
\item[Received in the \textit{joining} state:] not possible, otherwise this problem is impossible. This is due to our Assumption
\item[Received in the \textit{thinking} state:] removes the fork from the list and remove the neighbor from the list. It sends back \texttt{ok}.
\item[Received in the \textit{hungry} state:] removes the fork from the list and removes the neighbor from the list. Then it checks if we have all the forks we need to eat. It sends back \texttt{ok}.
\item[Received in the \textit{eating} state:] removes the fork from the list and removes the neighbor from the list. Then it continues eating. Sends back \texttt{ok}.
\item[Received in the \textit{leaving} state:] removes the fork from the list and removes the neighbor from the list. It sends back \texttt{ok}.
\item[Received in the \textit{gone} state:] not possible.
\end{description}

\subsection{Actions for Incoming Leaving Message Acknowledgement Messages (M\ref{M:leaving_ack})}
\begin{description}
\item[Received in the \textit{joining} state:] not possible.
\item[Received in the \textit{thinking} state:] not possible.
\item[Received in the \textit{hungry} state:] not possible.
\item[Received in the \textit{eating} state:] not possible.
\item[Received in the \textit{leaving} state:] Try to contact the other neighbors, remove that neighbor from the list of neighbors.
\item[Received in the \textit{gone} state:] not possible.
\end{description}

\subsection{Actions for Incoming \texttt{become\_hungry} Messages (M\ref{M:become_hungry})}
\begin{description}
\item[Received in the \textit{joining} state:] not possible
\item[Received in the \textit{thinking} state:] sends out requests to all neighbors for forks and then transition to hungry state.
\item[Received in the \textit{hungry} state:] justs stay hungry.
\item[Received in the \textit{eating} state:] not possible.
\item[Received in the \textit{leaving} state:] not possible.
\item[Received in the \textit{gone} state:] not possible.
\end{description}

\subsection{Actions for Incoming \texttt{stop\_eating} Messages (M\ref{M:stop_eating})}
\begin{description}
\item[Received in the \textit{joining} state:] not possible.
\item[Received in the \textit{thinking} state:] not possible.
\item[Received in the \textit{hungry} state:] not possible.
\item[Received in the \textit{eating} state:] stops eating, sends out the forks to all the processes that requested them, then transitions to the \emph{thinking} state.
\item[Received in the \textit{leaving} state:] not possible.
\item[Received in the \textit{gone} state:] not possible.
\end{description}

\subsection{Actions for Incoming \texttt{leave} Messages (M\ref{M:leave})}
\begin{description}
\item[Received in the \textit{joining} state:] not possible.
\item[Received in the \textit{thinking} state:] transitions to \emph{leaving}, which sends messages to all neighbors to say that it is leaving. Once all processes give \texttt{ok}, then it transitions to gone.
\item[Received in the \textit{hungry} state:] transitions to \emph{leaving}, which sends message to all neighbors that he's leaving. Once all processes give \texttt{ok}, then it transitions to gone.
\item[Received in the \textit{eating} state:] transitions to \emph{leaving}, which sends message to all neighbors that he's leaving. Once all processes give \texttt{ok}, then it transitions to gone.
\item[Received in the \textit{leaving} state:] stay leaving.
\item[Received in the \textit{gone} state:] not possible.
\end{description}


\subsection{How a new philosopher informs its neighbors that it has joined the network}
Sends joining requests to all of their neighbors.

\subsection{How a new philosopher knows that its neighbors are aware that it has joined the network}
Waits for joining request acknowledgement messages from all of its neighbors.
\subsection{How a philosopher informs its neighbors that it is leaving the network}
Sends leaving notifications to all of their neighbors.

\subsection{How a philosopher knows that its neighbors are aware that it is leaving the network}
Waits for leaving notification acknowledgements from all of its neighbors.

\section{Allowed Assumptions}

\subsection{External Controllers}
\begin{enumerate}[\text{A}1]
\item \label{A:finite_time_eating} Only storage processes will receive requests from the outisde world.

\item \label{A:no_invalid_signals} External controllers will not send duplicate or invalid control signals.

\item \label{A:E_guarantees_nodes_entering_network} If a process $p_1$ receives a joining request from another process $p_2$, external controllers will not send signals to ask $p_1$ to leave until $p_2$ successfully joins the network.
\end{enumerate}

\subsection{Misc.}
\begin{enumerate}[\text{A}1]
\setcounter{enumi}{3}
\item \label{A:message_never_lost} Messages are never lost; sufficient time is allowed for a process to bootstrap itself before other processes send it messages.
\item There is ample time to rebalance when a node leaves or joins.
\end{enumerate}


\section{Proof of Correctness}


\subsection{Proof of Safety Properties}
Suppose the parameter $m$, which is a nonnegative integer, is given.

\begin{enumerate}[S1]
\item {\bfseries initially} {\it p.joining}

$p$ is given the state of $joining$ in which the philosopher $p$ is requesting to join the group and cannot possibly gain any other state until granted acceptance.


\item $\#(\text{storage processes}) = 2^m.$

\item {\it p.joining} {\bfseries next} {\it (p.joining $\vee$ p.available)}

This requirement is satisfied because $p$ can be constantly trying to join the party but may be waiting infinitely or it can be granted the state of available (which is the only initial state in the party).

\item {\it p.available} {\bfseries next} {\it (p.available $\vee$ p.hungry $\vee$ p.leaving)}

When available, the process $p$ can continue \available, the external controller can issue the order to become hungry, or the controller may tell the process to leave. No other "state" transitions are available to the process at the $available$ state. 

\item {\it p.hungry} {\bfseries next} {\it (p.hungry $\vee$ p.eating $\vee$ p.leaving)}

If a process $p$ is told by the external controller to become \emph{hungry}, then it may be told to leave, it may become \emph{eating} due to its hungry nature, or $p$ may remain \emph{hungry}. 

\item {\it p.eating} {\bfseries next} {\it (p.eating $\vee$ p.available $\vee$ p.leaving)}

If a process $p$ is $eating$, then only three cases are possible to the process. First, nothing may happen and the process will continue $eating$. Second, the external controller can tell the process to \texttt{stop\_ eating}, in which $p$ would become $available$. Third, the external controller can also tell the process to \texttt{leave}, in which $p$ would become $leaving$. No other transitions are available at this stage.

\item {\it p.leaving} {\bfseries next} {\it (p.leaving $\vee$ p.gone)}

When a philosopher $p$ has been told to leave by the external controller, it is destined to leave thus may continue its cleanup and remain in the $leaving$ stage or the philosopher could complete the $leaving$ state and leave, successfully terminating and entering the $gone$ state.

\item {\it p.gone} {\bfseries next} {\it (p.gone)}

When a philosopher $p$ is $gone$, the philosopher may not join again (implying it may not reach anymore states) and thus is in the fixed state of $gone$.

\item {\it p.eating} $\Rightarrow \langle \forall q | q \in p.neighbors \rhd \neg q.eating \rangle$
(when a philosopher $p$ is $eating$, none of its neighbors is $eating$)

When a philosopher $p$ is $eating$, then it holds all of its forks that it shares with its neighbors and since a philosopher needs all of the forks it shares with its neighbors, that philosopher with the forks will be the only one eating.


\item \label{S:mutual_neighbors} {\it (p.thinking $\vee$ p.hungry $\vee$ p.eating)} $\Rightarrow \langle \forall q | q \in p.neighbors \rhd p \in q.neighbors \rangle$
(when a philosopher $p$ is $thinking$, $hungry$, or $eating$, each of $p$'s neighbors knows that $p$ is one of its neighbors)

After joining, a leaving philosopher $q$ knows its neighbors and in each state $thinking$, $hungry$, or $eating$, the neighbors list is updated if a neighbor leaves. Thus, each state has a real-time copy of the neighboring philosophers.

Before the philosopher $q$ can leave or remove a neighbor $p$ who is either $thinking$, $hungry$, or $eating$ from $q.neighbors$, we guarantee that $p$ remove $q$ first.

\item {\it p.gone} $\Rightarrow \langle \forall q  \rhd p\not\in q.neighbors \rangle$
(when a philosopher $p$ is $gone$, it is not in any other philosopher's set of neighbors)

If $p$ is \emph{gone}, from our algorithm we know that $p.neighbors = \emptyset$. From this fact and from the safety property S\ref{S:mutual_neighbors}, we know that if $q$ is $thinking$, $hungry$, or $eating$, then $p$ cannot be a neighbor $q$. If $q$ is \emph{leaving} or \emph{gone}, $q.neighbors = \emptyset$ so $p\not\in q.neighbors.$ If $q$ is \emph{joining}, $p$ cannot possibly be a neighbor of $q$ due to our Assumption A\ref{A:E_guarantees_nodes_entering_network} that guarantees joining philosophers to be able to enter the network. Hence, we have covered all cases.



\item When a storage process $p$ receives a store/retrieve message with key $k$, if $k = p.id$, then it performs an action. If not, then it forwards the request to an apppropriate process.

\item $1 \leq n:= \#nodes \leq 2^m.$

\item $node_1.id \neq node_2.id$ if $node_1 \neq node_2.$

\item $node_i.id \in \{0,1,2,\ldots, 2^m - 1\}$ for all $0\leq i \leq n - 1.$ 

\item Without loss of generality, we can let
$0 \leq node_1.id < node_2.id < \cdots < node_n.id \leq 2^m - 1.$
Then for $i= 0, 1, \ldots, n - 1,$ $node_i$ hosts storage processes with id in the set $\{node_i.id, node_i.id + 1, node_i.id + 2, \ldots, node_{i+1}.id - 1\}$ in modulo $2^m$ calculation and with the notation $node_{n} = node_0.$

\item All storage processes are named in the global Erlang name registry.

\item Each node must register at least one non-storage process (so that the node is always discoverable).


\item If $\#node = n < 2^m$, then a new node can always join the system.

\item A storage process can communicate another storage process only if they are neighbors.

\item  A storage process can communicate a non-storage process only if they are in the same node.

\item A non-storage process can communicate a storage process only if they are in the same node.

\item  A non-storage process in node $i$ can communicate a non-storage process only if it is in the nodes that host neighbors of the storage processes hosted by node $i$.

\item Every message from the outside world (except for \texttt{leave}) must be responded to except for when relevant processes crash.
\end{enumerate}



\section{Proof of Progress Properties}
\begin{enumerate}[PG1]
\item
$p.joining$ $\leadsto^*$ $p.available$ ($^*$ if its neighbors remain in the network long enough) 

\indent After philosopher $p$ has started up, it has given itself the $joining$ state. Assuming that the neighbors in which $p$ knows about are running correctly and the network runs as expected and Assumption A\ref{A:E_guarantees_nodes_entering_network}, all other philosophers are bound to hear $p$'s request to join eventually and thus $p$ is guaranteed to be given the state $available$.

\item 
$p.leaving$ $\leadsto$ $p.gone$
When $p$ is in the \emph{leaving} state, it sends leaving notifications to all its neighbors. Since messages are never lost, all of its neigbors will eventually get the messages and send acknowledgements back. Once it receives all acknowledgements, it can transition to \emph{gone}.

\item 
$p.gone$ $\leadsto$ (all other nodes detect and rebalance)

\end{enumerate}
%~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

\section{Appendix: Relevant Code}
\begin{lstlisting}
TODO
\end{lstlisting}


\end{document}
